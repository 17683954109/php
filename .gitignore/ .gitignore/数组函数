
//非引用赋值，不会对数组本身产生影响

//array_map对数组的每一个元素都进行一次函数回调处理
用法：
array_map('回调函数',数组名);

例:
$arr=[-10,-9,3,5];

print_r(array_map('callback',$arr));

function callback($y){
  return $y+10;
}

运行结果就是数组的每一位都加上了10


/\/\/\/\/\/\/\/\/\/\/\/\/\/\数组值的排序/\/\/\/\/\/\/\/\/\

//会对数组本身产生改变，也就是引用赋值

sort($arr);  //对数组进行由小到大排序，不保留原始键名

rsort($arr);  //对数组进行由大到小排序，不保留键名

asort($arr);  //对数组进行由小到大排序，保留原始键名

arsort($arr);  //对数组进行由大到小排序，保留原始键名

/\/\/\/\/\/\/\/\/\/\/\/\/\/\数组键名的排序/\/\/\/\/\/\/\/\/\

ksort($arr);  //对数组的键名进行正序（升序）排列

krsort($arr);  //对数组进行反序（降序）排列

/\/\/\/\/\/\/\/\/\/\/\/\/\自然排序（按照人的思维）/\/\/\/\/\

$arr=['img12','img5','img10','img2'];

按照sort($arr); 来排序的话，是一个字符一个字符来进行比较的

也就是说img后面是1的排在第一位

如下：
$arr=['img10','img12','img2','img5'];

按照我们的正常思维，这样肯定是不对的

于是就有了natsort($arr);

来按照我们的思维方式来排序

结果就是：

$arr=['img2','img5','img10','img12'];

/\/\/\/\/\/\/\/\/\/\/\/\用户自定义排序/\/\/\/\/\/\/\

对于多维数组和没有规律的数组，无法使用定义好的排序规则

//回调函数的返回说明

      -1：这个值排在第二个值的前面
      0:两个值相等
      1:这个值排在第二值的后面

//回调函数的参数说明
    回调函数必须有两个参数
    两个参数进行比较，如果是多维数组，还需要对里面的进行深入调用，必须取到实际的键名和值，才能比较



usort($arr,'回调函数');

例：

$arr=array(
  array('name'=>'张三','age'=>18,'sex'=>'男'),
  array('name'=>'李四','age'=>17,'sex'=>'男'),
  array('name'=>'王二','age'=>10,'sex'=>'男'),
);
usort($arr,'show');

  function show($a,$b){
    if($a['age']<$b['age']){
    return -1;
    }
    if($a['age']==$b['age']){
    return 0;
    }
    if($a['age']>$b['age']){
    return 1;
    }
  }
  
  此时就是按照二级数组中的age键名的值进行排序
  
  
